// This file has been autogenerated from a class added in the UI designer.

using System;

using Foundation;
using AppKit;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Threading;

namespace Evacuation
{
    public partial class viewMoving : NSViewController
    {
        private Object _lock = new object();

        public string Pod = "";
        public Hypervisor SourceHyp;
        public List<Hypervisor> DestHyps = new List<Hypervisor>();

        bool PauseQueue = false;
        bool Moving = true;

        HypTable.DataSource hypDS = new HypTable.DataSource();
        VmTable.DataSource vmDS = new VmTable.DataSource();

        public viewMoving(IntPtr handle) : base(handle)
        {
        }

        public override void ViewDidLoad()
        {
            base.ViewDidLoad();

            tblDestHyps.DataSource = hypDS;
            tblDestHyps.Delegate = new HypTable.Delegate(hypDS);

            tblSourceVms.DataSource = vmDS;
            tblSourceVms.Delegate = new VmTable.Delegate(vmDS);

            lblSource.StringValue = SourceHyp.HostName;
            new Thread(() =>
            {
                Reload();
                EvacuateHyp();
            }).Start();
            new Thread(() => UpdateProgress()).Start();
        }

        private void Reload()
        {
            lblStatus.Set("Refreshing Hypervisor/VM Info...");
            RefreshData();
            lblStatus.Set("Hypervisor/VM Info Loaded...");
        }

        private void RefreshData()
        {
            lock (_lock)
            {
                bool loaded = false;
                while (!loaded)
                {
                    SourceHyp.Vms.Clear();
                    try
                    {
                        Parallel.Invoke(
                            () => SourceHyp.LoadSourceHyp(),
                            () =>
                            {
                                Parallel.ForEach(DestHyps, hyp => { hyp.LoadDestHyp(); });
                            }
                        );

                        hypDS.Hyps.Clear();
                        hypDS.Hyps.AddRange(DestHyps);
                        hypDS.Hyps.Sort();

                        vmDS.Vms.Clear();
                        vmDS.Vms.AddRange(SourceHyp.Vms);
                        this.BeginInvokeOnMainThread(() =>
                        {
                            tblDestHyps.ReloadData();
                            tblSourceVms.ReloadData();
                        });
                        loaded = true;
                    }
                    catch
                    {
                        lblStatus.Set("Problem encountered while loading hyp info.  Will retry in 30 sec.");
                        Thread.Sleep(30000);
                    }
                }
            }
        }

        private Hypervisor ChooseDest(VirtualMachine VM)
        {
            lock (_lock)
            {
                List<Hypervisor> destList = new List<Hypervisor>();
                destList.AddRange(DestHyps.Where(x => x.MemoryFree > VM.Memory));
                return destList
                        .OrderBy(x => x.GetHostgroupCount(VM.HostGroup))
                        .ThenByDescending(x => (Math.Floor(x.DiskFree * 2) / 2))
                        .ThenByDescending(x => x.CoresRemaining)
                        .ThenByDescending(x => x.MemoryFree).First();
            }
        }

        private void UpdateProgress()
        {
            prgMove.Range(0, 1);
            while (Moving)
            {
                var tasks = SourceHyp.GetProgress();

                if (tasks.Count > 0)
                {
                    prgMove.Hide(false);
                    prgMove.Set(tasks[0]);
					lblStatus.Set("Moves in progress: " + tasks.Count);
				}
				if (tasks.Count > 1)
				{
					prgMove2.Hide(false);
					prgMove2.Set(tasks[1]);
				}
				if (tasks.Count > 2)
				{
					prgMove3.Hide(false);
					prgMove3.Set(tasks[2]);
				}
                if (tasks.Count < 3)
                {
                    prgMove3.Hide();
                    prgMove3.Set(0);
                }
				if (tasks.Count < 2)
				{
					prgMove2.Hide();
                    prgMove2.Set(0);
				}
				if (tasks.Count < 1)
				{
					prgMove.Hide();
                    prgMove.Set(0);
					if (PauseQueue) lblStatus.Set("Queue Paused...");
				}
                Thread.Sleep(2000);
            }
        }

        private void EvacuateHyp()
        {
            while (SourceHyp.Vms.Count > 0)
            {
                try
                {
					List<string> movingHostgroups = new List<string>();
					lblStatus.Set("Queueing work... " + vmDS.Vms.Count() + " vms");
					var multiMove = new List<VirtualMachine>(SourceHyp.Vms);
					Parallel.ForEach(multiMove, new ParallelOptions { MaxDegreeOfParallelism = 3 }, curVm =>
					{
						while (PauseQueue) { Thread.Sleep(2000); }
						bool hgSingle = false;
						lock (movingHostgroups)
						{
							hgSingle = !(movingHostgroups.Contains(curVm.HostGroup));
							if (hgSingle) movingHostgroups.Add(curVm.HostGroup);
						}
						if (hgSingle)
						{
							try
							{
								var dstHyp = ChooseDest(curVm);
								prgMove.Hide(false);
								var mover = new HypMover() { SourceHyp = SourceHyp.HostName, DestHyp = dstHyp.HostName, VMUUID = curVm.UUID };
								foreach (var netInfo in curVm.Networks) mover.VIFtoDstNetwork.Add(netInfo.VifUUID, dstHyp.NetworkByVlan[netInfo.VlanID]);
								mover.MoveVM();
							}
							catch
							{

							}
							movingHostgroups.Remove(curVm.HostGroup);
						}
						RefreshData();
					});
                }
                catch (Exception ex)
                {

                }

            }
            prgMove.Hide();
            lblStatus.Set("Work completed!");
            btnStartNewHost.Hide(false);
            btnPatchHost.Hide(false);
            Moving = false;
        }

        public override void PrepareForSegue(NSStoryboardSegue segue, NSObject sender)
        {
            base.PrepareForSegue(segue, sender);

            // Take action based on Segue ID
            switch (segue.Identifier)
            {
                case "ReturnSelectHyp":
                    ((viewSelectHyp)segue.DestinationController).Pod = Pod;
                    ((NSWindowController)this.View.Window.WindowController).Close();
                    break;
            }
        }

        partial void cmdPauseQueue(NSObject sender)
        {
            PauseQueue = !PauseQueue;
            btnPauseQueue.Title = PauseQueue ? "Resume Queue" : "Pause Queue";
        }

        partial void cmdPatchHost(NSObject sender)
        {
            lblStatus.Set("Checking for patches...");
            new Thread(() =>
            {
                var patches = Patch.LoadPatches(SourceHyp);
                try
                {
					foreach (var patch in patches)
					{
						lblStatus.Set("Applying " + patch.Namelabel + " to " + SourceHyp.HostName);
						prgMove.Hide();
						Patch.ApplyPatch(patch, SourceHyp);
					}
					lblStatus.Set("Patch Attempt Finished");
				}
                catch (Exception e)
                {
                    lblStatus.Set("Patch Attempt Failed");
                    System.Diagnostics.Debug.WriteLine(e.ToString());
                }

            }).Start();
        }

        partial void cmdLaunchConsole(NSObject sender)
        {
            SourceHyp.OpenIdrac();
        }

		partial void cmdCopyMoob(NSObject sender)
		{
			SourceHyp.LaunchMoobConsole();
		}
    }
}
