// This file has been autogenerated from a class added in the UI designer.

using System;

using Foundation;
using AppKit;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Threading;

namespace Evacuation
{
    public partial class viewMoving : NSViewController
    {
        private Object _lock = new object();

        public string Pod = "";
        public Hypervisor SourceHyp;
        public List<Hypervisor> DestHyps = new List<Hypervisor>();

        bool PauseQueue = false;
        bool Moving = true;

        HypTable.DataSource hypDS = new HypTable.DataSource();
        VmTable.DataSource vmDS = new VmTable.DataSource();

        private Queue<VirtualMachine> MoveQueue = new Queue<VirtualMachine>();

        public viewMoving(IntPtr handle) : base(handle)
        {
        }

        public override void ViewDidLoad()
        {
            base.ViewDidLoad();

            tblDestHyps.DataSource = hypDS;
            tblDestHyps.Delegate = new HypTable.Delegate(hypDS);

            tblSourceVms.DataSource = vmDS;
            tblSourceVms.Delegate = new VmTable.Delegate(vmDS);

            lblSource.StringValue = SourceHyp.HostName;
            new Thread(() =>
            {
                Reload();
                EvacuateHyp();
            }).Start();
            new Thread(() => UpdateProgress()).Start();
        }

        private void Reload()
        {
            lblStatus.Set("Refreshing Hypervisor/VM Info...");
            RefreshData();
            lblStatus.Set("Hypervisor/VM Info Loaded...");
        }

        private void RefreshData()
        {
            lock (_lock)
            {
                bool loaded = false;
                while (!loaded)
                {
                    SourceHyp.Vms.Clear();
                    try
                    {
                        Parallel.Invoke(
                            () => SourceHyp.LoadSourceHyp(),
                            () =>
                            {
                                Parallel.ForEach(DestHyps, hyp => { hyp.LoadDestHyp(); });
                            }
                        );

                        hypDS.Hyps.Clear();
                        hypDS.Hyps.AddRange(DestHyps);
                        hypDS.Hyps.Sort();

                        vmDS.Vms.Clear();
                        vmDS.Vms.AddRange(SourceHyp.Vms);
                        this.BeginInvokeOnMainThread(() =>
                        {
                            tblDestHyps.ReloadData();
                            tblSourceVms.ReloadData();
                        });
                        loaded = true;
                    }
                    catch
                    {
                        lblStatus.Set("Problem encountered while loading hyp info.  Will retry in 30 sec.");
                        Thread.Sleep(30000);
                    }
                }
            }
        }

        private Hypervisor ChooseDest(VirtualMachine VM)
        {
            lock (_lock)
            {
                List<Hypervisor> destList = new List<Hypervisor>();
                destList.AddRange(DestHyps.Where(x => x.MemoryFree > VM.Memory));
                return destList
                        .OrderBy(x => x.GetHostgroupCount(VM.HostGroup))
                        .ThenByDescending(x => (Math.Floor(x.DiskFree * 2) / 2))
                        .ThenByDescending(x => x.CoresRemaining)
                        .ThenByDescending(x => x.MemoryFree).First();
            }
        }

        private void UpdateProgress()
        {
            prgMove.Range(0, 1);
            while (Moving)
            {
                //prgMove.Set(SourceHyp.GetProgress());
                //int TaskCount;
                //prgMove.Set(SourceHyp.GetProgress(out TaskCount));
                //lblStatus.Set("Moves in progress: " + TaskCount);

                var tasks = SourceHyp.GetProgress();

                if (tasks.Count > 0)
                {
                    prgMove.Hide(false);
                    prgMove.Set(tasks[0]);
					lblStatus.Set("Moves in progress: " + tasks.Count);
				}
				if (tasks.Count > 1)
				{
					prgMove2.Hide(false);
					prgMove2.Set(tasks[1]);
				}
				if (tasks.Count > 2)
				{
					prgMove3.Hide(false);
					prgMove3.Set(tasks[2]);
				}
                if (tasks.Count < 3)
                {
                    prgMove3.Hide();
                    prgMove3.Set(0);
                }
				if (tasks.Count < 2)
				{
					prgMove2.Hide();
                    prgMove2.Set(0);
				}
				if (tasks.Count < 1)
				{
					prgMove.Hide();
                    prgMove.Set(0);
					if (PauseQueue) lblStatus.Set("Queue Paused...");
				}
                Thread.Sleep(2000);
            }
        }

        private void EvacuateHyp()
        {
            while (SourceHyp.Vms.Count > 0)
            {
                lblStatus.Set("Queueing work... " + vmDS.Vms.Count() + " vms");
                var multiMove = new List<VirtualMachine>(SourceHyp.Vms);
                Parallel.ForEach(multiMove, new ParallelOptions { MaxDegreeOfParallelism = 3 }, curVm =>
                {
                    while (PauseQueue) { Thread.Sleep(2000); }
                    try
                    {
                        var dstHyp = ChooseDest(curVm);
                        prgMove.Hide(false);
                        var mover = new HypMover() { SourceHyp = SourceHyp.HostName, DestHyp = dstHyp.HostName, VMUUID = curVm.UUID };
                        foreach (var netInfo in curVm.Networks) mover.VIFtoDstNetwork.Add(netInfo.VifUUID, dstHyp.NetworkByVlan[netInfo.VlanID]);
                        mover.MoveVM();
                    }
                    catch
                    {

                    }
                    RefreshData();
                });
            }
            prgMove.Hide();
            lblStatus.Set("Work completed!");
            btnStartNewHost.Hide(false);
            btnPatchHost.Hide(false);
            Moving = false;
        }

        public override void PrepareForSegue(NSStoryboardSegue segue, NSObject sender)
        {
            base.PrepareForSegue(segue, sender);

            // Take action based on Segue ID
            switch (segue.Identifier)
            {
                case "ReturnSelectHyp":
                    var dest = (viewSelectHyp)segue.DestinationController;
                    dest.Pod = Pod;
                    ((NSWindowController)this.View.Window.WindowController).Close();
                    break;
            }
        }

        partial void cmdPauseQueue(NSObject sender)
        {
            PauseQueue = !PauseQueue;
            btnPauseQueue.Title = PauseQueue ? "Resume Queue" : "Pause Queue";
        }

        partial void cmdPatchHost(NSObject sender)
        {
            new Thread(() => PatchHyp()).Start();
        }

        private void PatchHyp()
        {
            var patches = Patch.LoadPatches(SourceHyp);
            foreach (var patch in patches)
            {
                lblStatus.Set("Applying " + patch.Namelabel + " to " + SourceHyp.HostName);
                prgMove.Hide();
                Patch.ApplyPatch(patch, SourceHyp);
            }
            lblStatus.Set("Patch Attempt Finished");
        }

        partial void cmdLaunchConsole(NSObject sender)
        {
            SourceHyp.OpenIdrac();
        }

		partial void cmdCopyMoob(NSObject sender)
		{
			SourceHyp.LaunchMoobConsole();
		}
    }
}
